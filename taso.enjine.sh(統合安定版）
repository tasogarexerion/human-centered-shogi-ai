cat > "$HOME/shogi/wrapper/taso_engine.sh" <<'SH'
#!/usr/bin/env bash
set -euo pipefail

# =========================================================
# TASO Engine ‚Äî FINAL MEMORY EDITION (STABLE + FULL)
# dlshogi(main) + dlshogi(preflight) + HumanScore
# BUNKER + (Êîª„ÇÅ/Âèó„Åë/„Éê„É©„É≥„Çπ) + COMEBACK + SUDDEN DEATH
# Optional: Local LLM commentary (silent fail)
# =========================================================

# ========= User toggles =========
TASO_SHOW="${TASO_SHOW:-0}"            # 1 => emit "info string ..."
TASO_DEBUG="${TASO_DEBUG:-0}"          # 1 => stderr debug
TASO_LOG="${TASO_LOG:-1}"              # 1 => CSV log
TASO_MIRACLE="${TASO_MIRACLE:-0}"      # 1 => even if mate seen, don't switch policy
TASO_USE_MOVECOUNT="${TASO_USE_MOVECOUNT:-1}"  # 0 => don't use MOVE_COUNT thresholds

# ========= HumanScore mode =========
# auto: infer„Åå‰Ωø„Åà„Çå„Å∞infer„ÄÅÁÑ°ÁêÜ„Å™„ÇâÊé®ÂÆö
# infer: inferÂõ∫ÂÆöÔºàÂ§±ÊïóÊôÇ„ÅØ0.50Ôºâ
# estimate: Êé®ÂÆöÂõ∫ÂÆöÔºàinfer‰Ωø„Çè„Å™„ÅÑÔºâ
# off: Â∏∏„Å´0.50ÔºàË°®Á§∫„Å†„ÅëÊ¨≤„Åó„ÅÑ‰∫∫Âêë„ÅëÔºâ
TASO_HWS_MODE="${TASO_HWS_MODE:-auto}"

# ========= HumanScore (infer or estimate) =========
estimate_hws() {
  # Êé®ÂÆöHumanScoreÔºà0.01„Äú0.99Ôºâ
  # Âü∫Êú¨Ôºöcp1ÔºàÂÖàÊâãË¶ñÁÇπ„ÅÆÁ¨¶Âè∑„ÅÆ„Åæ„ÅæÔºâ„Çí„Ç∑„Ç∞„É¢„Ç§„ÉâÂ§âÊèõ
  # Ë£úÊ≠£ÔºöspreadÔºàcp1-cp2Ôºâ„ÅåÂ§ß„Åç„ÅÑ„Åª„Å©„Äå‰∫∫ÈñìÁöÑ„Å´ÂàÜ„Åã„Çä„ÇÑ„Åô„ÅÑ„Äç=ÂãùÁéá„ÇíÂ∞ë„Åó‰∏ä„Åí„Çã
  local cp1="${1:-0}"
  local spread="${2:-0}"

  # awk „ÅÆ exp() „Çí‰Ωø„ÅÜÔºàmacOSÊ®ôÊ∫ñawk„ÅßOKÔºâ
  awk -v cp="$cp1" -v sp="$spread" -v mc="$MOVE_COUNT" 'BEGIN{
    # spreadË£úÊ≠£ÔºàÂäπ„Åç„Åô„ÅéÈò≤Ê≠¢Ôºâ
    if (sp > 800) sp = 800;
    if (sp < -800) sp = -800;

    # ÁµÇÁõ§„Åª„Å© spread „ÅÆÂΩ±Èüø„ÇíÂº±„ÇÅ„Çã
    w = (mc > 80 ? 0.15 : 0.30);
    eff = cp + w*sp;

    x = eff / 450.0;
    h = 1.0 / (1.0 + exp(-x));

    # „ÇØ„É™„ÉÉ„Éó
    if (h < 0.01) h = 0.01;
    if (h > 0.99) h = 0.99;

    printf "%.2f\n", h;
  }'
}

get_hws() {
  local cp="${1:-0}" spread="${2:-0}"

  case "$TASO_HWS_MODE" in
    off)
      echo "0.50"
      return 0
      ;;
    estimate)
      estimate_hws "$cp" "$spread"
      return 0
      ;;
    infer|auto)
      ;;
    *)
      # ‰∏çÊòéÂÄ§„ÅØautoÊâ±„ÅÑ
      ;;
  esac

  # infer „Åå‰Ωø„Åà„Çã„Å™„Çâ‰Ωø„ÅÜÔºàauto/inferÔºâ
  if [ "$TASO_HWS_MODE" != "estimate" ] \
     && [ -n "$CURRENT_POS" ] \
     && [ -f "$HUMAN_AI" ] \
     && [ -x "$HUMAN_PY" ]; then
    local out
    out="$("$HUMAN_PY" "$HUMAN_AI" "$CURRENT_POS" "$cp" "$spread" 2>/dev/null || true)"
    # Â¶•ÂΩì„Å™Êï∞ÂÄ§„Å£„ÅΩ„ÅÑÊôÇ„Å†„ÅëÊé°Áî®
    if echo "$out" | awk 'BEGIN{ok=0} /^[0-9]+\.[0-9]+$/ { if($1>=0 && $1<=1) ok=1 } END{exit(ok?0:1)}'; then
      echo "$out"
      return 0
    fi
    # inferÂ§±Êïó ‚Üí auto„Å™„ÇâÊé®ÂÆö„ÄÅinferÂõ∫ÂÆö„Å™„Çâ0.50
    if [ "$TASO_HWS_MODE" = "infer" ]; then
      echo "0.50"
      return 0
    fi
  fi

  # auto fallback
  estimate_hws "$cp" "$spread"
}

# ========= Timing / safety =========
PREFLIGHT_MS="${PREFLIGHT_MS:-30}"     # 20-50ms recommended
ENGINE_READ_TIMEOUT="${ENGINE_READ_TIMEOUT:-2}"
ENGINE_LINE_LIMIT="${ENGINE_LINE_LIMIT:-6000}"

# ========= Paths =========
ROOT="$HOME/shogi"
DL="$ROOT/engines/dlshogi/build/dlshogi"
DL_MODEL="$ROOT/models/dlshogi_model/model.onnx"

HUMAN_PY="$ROOT/.venv/bin/python"
HUMAN_AI="$ROOT/humanscore_ai/infer.py"

# ========= dlshogi params =========
DL_THREADS="${DL_THREADS:-10}"
MULTIPV="${MULTIPV:-5}"
PREFLIGHT_THREADS="${PREFLIGHT_THREADS:-2}"
PREFLIGHT_MULTIPV="${PREFLIGHT_MULTIPV:-3}"

# ========= SUDDEN DEATH =========
SUDDEN_DEATH_MODE=0
TASO_SD_MPV_MIN="${TASO_SD_MPV_MIN:-2}"
TASO_SD_MPV_MAX="${TASO_SD_MPV_MAX:-3}"
TASO_SD_SCORE_LIMIT="${TASO_SD_SCORE_LIMIT:--600}"
declare -A PV_MOVES

# ========= COMEBACK threshold =========
COMEBACK_CP="${COMEBACK_CP:--600}"

# ========= BUNKER threshold =========
BUNKER_SPREAD="${BUNKER_SPREAD:-300}"  # cp1 - cp2

# ========= Optional LLM =========
TASO_LLM="${TASO_LLM:-0}"  # 1 => enable
TASO_LLM_HELPER="${TASO_LLM_HELPER:-$ROOT/wrapper/taso_llm.py}"
TASO_LLM_MODEL="${TASO_LLM_MODEL:-}"
TASO_LLM_TIMEOUT_SEC="${TASO_LLM_TIMEOUT_SEC:-0.8}"

say(){ [ "$TASO_SHOW" = "1" ] && echo "info string $*"; }
dbg(){ [ "$TASO_DEBUG" = "1" ] && echo "[DEBUG] $*" >&2; }

# Silent & safe LLM call: 3 lines max, failure => silence
llm_say(){
  [ "$TASO_SHOW" = "1" ] || return 0
  [ "$TASO_LLM" = "1" ] || return 0
  [ -f "$TASO_LLM_HELPER" ] || return 0
  [ -f "$TASO_LLM_MODEL" ] || return 0
  [ -x "$HUMAN_PY" ] || return 0

  local payload="$1"
  local out=""
  out="$(
    TASO_LLM_MODEL="$TASO_LLM_MODEL" \
    TASO_LLM_TIMEOUT_SEC="$TASO_LLM_TIMEOUT_SEC" \
    "$HUMAN_PY" "$TASO_LLM_HELPER" <<<"$payload" 2>/dev/null
  )" || true

  [ -n "$out" ] || return 0
  echo "$out" | head -n 3 | while IFS= read -r l; do
    [ -n "$l" ] && echo "info string üó£ $l"
  done
}

# ========= Dummy mode =========
DUMMY_MODE=0
if [ ! -x "$DL" ] || [ ! -f "$DL_MODEL" ]; then
  DUMMY_MODE=1
fi

# ========= State =========
CURRENT_POS=""
MOVE_COUNT=0
LAST_SCORE=0
LAST_MATE=0

# ========= FDs =========
exec 3>/dev/null 4</dev/null 7>/dev/null 8</dev/null

cleanup(){
  { echo "quit" >&3; } 2>/dev/null || true
  { echo "quit" >&7; } 2>/dev/null || true
}
trap cleanup EXIT INT TERM

mate_num(){
  # Êï∞ÂÄ§„ÅÆ„ÅøÈÄö„ÅôÔºàË≤†„ÅÆmate„ÇÇ‰øùÊåÅÔºâ
  if [[ "${1:-}" =~ ^-?[0-9]+$ ]]; then
    echo "$1"
  else
    echo "0"
  fi
}

# Read until token from FD (no forwarding), with timeout/limit
read_until_token_discard(){
  local fd="$1" token="$2" line n=0
  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" line <&"$fd"; do
    n=$((n+1))
    [[ "$line" == "$token"* ]] && return 0
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && return 1
  done
  return 1
}


# ========= bunker =========
bunker_flag(){
  local cp1="$1" cp2="$2"
  local spread=$((cp1 - cp2))
  if [ "$spread" -ge "$BUNKER_SPREAD" ] && [ "$cp1" -ge -800 ] && [ "$cp1" -le 800 ]; then
    echo "1 $spread"
  else
    echo "0 $spread"
  fi
}

# ========= Start engines =========
if [ "$DUMMY_MODE" = "0" ]; then
  coproc DL_ENG { "$DL" --device metal --model "$DL_MODEL" --threads "$DL_THREADS" --multipv "$MULTIPV"; }
  exec 3>&"${DL_ENG[1]}" 4<"${DL_ENG[0]}"

  coproc PF_ENG { "$DL" --device metal --model "$DL_MODEL" --threads "$PREFLIGHT_THREADS" --multipv "$PREFLIGHT_MULTIPV"; }
  exec 7>&"${PF_ENG[1]}" 8<"${PF_ENG[0]}"
else
  dbg "DUMMY_MODE=1 (dlshogi or model missing)"
fi

# ========= Preflight: take cp1/cp2 at max depth =========
preflight_analyze(){
  local cp1=0 cp2=0
  local best_d1=-1 best_d2=-1

  echo "$CURRENT_POS" >&7
  echo "go movetime $PREFLIGHT_MS" >&7

  local out n=0
  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" out <&8; do
    n=$((n+1))

    if [[ "$out" == info* ]] && [[ "$out" == *"score cp"* ]]; then
      local d mpv cp
      d="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="depth"){print $(i+1); exit}}' 2>/dev/null || echo "-1")"
      mpv="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="multipv"){print $(i+1); exit}}' 2>/dev/null || echo "1")"
      cp="$(echo "$out" | sed 's/.*score cp //' | awk '{print $1}' 2>/dev/null || echo "")"

      if [ -n "$cp" ]; then
        if [ "$mpv" = "1" ] && [ "$d" -ge "$best_d1" ]; then best_d1="$d"; cp1="$cp"; fi
        if [ "$mpv" = "2" ] && [ "$d" -ge "$best_d2" ]; then best_d2="$d"; cp2="$cp"; fi
      fi
    fi

    [[ "$out" == bestmove* ]] && break
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
  done

  [ -z "${cp2:-}" ] && cp2="$cp1"
  echo "$cp1 $cp2 $((cp1 - cp2))"
}

# ========= Pump main engine until bestmove (track cp/mate + PV for sudden death) =========
pump_until_bestmove(){
  local out n=0
  local best_depth=-1
  local best_cp="$LAST_SCORE"
  local best_mate="$LAST_MATE"

  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" out <&4; do
    n=$((n+1))

    if [[ "$out" == info* ]]; then
      # capture PV per multipv (for sudden death pick)
      if [[ "$out" == *" multipv "* ]] && [[ "$out" == *" pv "* ]]; then
        local mpv pv
        mpv="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="multipv"){print $(i+1); exit}}' 2>/dev/null || echo "")"
        pv="$(echo "$out" | sed 's/.* pv //' | awk '{print $1}' 2>/dev/null || echo "")"
        [ -n "$mpv" ] && [ -n "$pv" ] && PV_MOVES["$mpv"]="$pv"
      fi

      # track mpv1 depth-max cp/mate
      if [[ "$out" == *" multipv 1 "* ]]; then
        local d
        d="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="depth"){print $(i+1); exit}}' 2>/dev/null || echo "-1")"
        [ -n "$d" ] || d=-1

        if [[ "$out" == *"score cp"* ]]; then
          local cp
          cp="$(echo "$out" | sed 's/.*score cp //' | awk '{print $1}' 2>/dev/null || echo "")"
          if [ -n "$cp" ] && [ "$d" -ge "$best_depth" ]; then best_depth="$d"; best_cp="$cp"; fi
        fi
        if [[ "$out" == *" mate "* ]]; then
          local mt
          mt="$(echo "$out" | sed 's/.*mate //' | awk '{print $1}' 2>/dev/null || echo "")"
          if [ -n "$mt" ] && [ "$d" -ge "$best_depth" ]; then best_depth="$d"; best_mate="$mt"; fi
        fi
      fi

      echo "$out"
      [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
      continue
    fi

    if [[ "$out" == bestmove* ]]; then
      LAST_SCORE="$best_cp"
      LAST_MATE="$best_mate"

      if [ "$SUDDEN_DEATH_MODE" = "1" ]; then
        local min="${TASO_SD_MPV_MIN}" max="${TASO_SD_MPV_MAX}"
        local choices=() i
        for i in $(seq "$min" "$max"); do
          [ -n "${PV_MOVES[$i]:-}" ] && choices+=("${PV_MOVES[$i]}")
        done
        if [ "${#choices[@]}" -gt 0 ]; then
          local pick="${choices[$((RANDOM % ${#choices[@]}))]}"
          say "‚ò†üéØ SUDDEN DEATH: pick multipv[$min..$max] => $pick"
          echo "bestmove $pick"
          PV_MOVES=()
          return 0
        fi
      fi

      PV_MOVES=()
      echo "$out"
      return 0
    fi

    echo "$out"
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
  done

  say "‚ö† engine timeout/limit ‚Üí emergency resign"
  PV_MOVES=()
  echo "bestmove resign"
  return 0
}

emit_comeback(){
  local score="$1" mate_raw="$2" hws="$3"
  local mate; mate="$(mate_num "$mate_raw")"

  if [ "$score" -le "$COMEBACK_CP" ]; then
    local type roadmap
    if [ "$mate" -lt 0 ]; then
  type="‚ò†üß± Âç≥Ê≠ªË≠¶Âëä"
  roadmap="ÂõûÈÅø‰∏çËÉΩ„Å™Ë©∞„ÅøÁ≠ã„ÅåÁ§∫ÂîÜ„Åï„Çå„Çã"
elif [ "$mate" -gt 0 ] && [ "$mate" -le 7 ]; then
  type="‚ò†‚ö° COMEBACK ‰∏ÄÊíÉÂøÖÊÆ∫"
  roadmap="Ë©∞„ÇÅ„Çç„ÉªÂøÖËá≥„ÅåÁ§∫ÂîÜ„Åï„Çå„Çã"
    else
      # sudden death gate
      if [ "$score" -le "$TASO_SD_SCORE_LIMIT" ] && [ "$mate" -eq 0 ]; then
        SUDDEN_DEATH_MODE=1
        type="‚ò†üéØ SUDDEN DEATH È†ìÊ≠ªË™òÁô∫"
        roadmap="Áõ∏Êâã„ÅåÂ¥©„Çå„ÇãÁ≠ã„Çí‚ÄúÁãô„Å£„Å¶‚ÄùÂá∫„ÅôÊñπÈáù"
      else
        SUDDEN_DEATH_MODE=0
        # simple hws gate
        local ok=0
        "$HUMAN_PY" - <<PY >/dev/null 2>&1 || ok=1
h=float("$hws"); import sys; sys.exit(0 if h>=0.45 else 1)
PY
        if [ "$ok" -eq 0 ]; then
          type="‚ò†üé≠ COMEBACK ‰∫ãÊïÖË™òÁô∫"
          roadmap="Âèó„Åë‰∏ÄÊäû„ÇíËø´„ÇãÂ±ïÈñã„ÅåÁ§∫ÂîÜ„Åï„Çå„Çã"
        else
          type="‚ò†üêç COMEBACK „Ç∏„ÉØ„Ç∏„ÉØ"
          roadmap="ÂΩ¢Âã¢„ÅÆÂÖ•„ÇåÊõø„Åà„ÇíÁãô„ÅÜÂ±ïÈñã„ÅåÁ§∫ÂîÜ„Åï„Çå„Çã"
        fi
      fi
    fi

    say "$type"
    say "‚ñ∂ $roadmap"
    llm_say "{\"phase\":\"ENDGAME\",\"event\":\"COMEBACK\",\"score\":$score,\"mate\":$mate,\"hws\":$hws}"

    if [ "$TASO_LOG" = "1" ]; then
      mkdir -p "$ROOT/taso_joseki"
      local poshash
      poshash="$(echo "$CURRENT_POS" | shasum | cut -c1-8 2>/dev/null || echo "00000000")"
      echo "$(date),$MOVE_COUNT,$score,$hws,$type,$poshash" >> "$ROOT/taso_joseki/comeback_log.csv" 2>/dev/null || true
    fi
  else
    SUDDEN_DEATH_MODE=0
  fi
}

# ========= Main loop =========
while IFS= read -r line; do
  dbg "IN: $line"

 if [[ "$line" == position* ]]; then
  CURRENT_POS="$line"
  if [ "$TASO_USE_MOVECOUNT" = "1" ]; then
    MOVE_COUNT="$(
      echo "$line" | awk '{
        for(i=1;i<=NF;i++){
          if($i=="moves"){ print (NF - i); exit }
        }
        print 0
      }'
    )"
  else
    MOVE_COUNT=0
  fi
fi

  if [[ "$line" == usi* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      echo "id name TASO (dummy: dlshogi/model missing)"
      echo "id author TASO"
      echo "usiok"
      continue
    fi

    # Forward ONLY main engine's usi lines to GUI
    echo "$line" >&3
    while IFS= read -r -t "$ENGINE_READ_TIMEOUT" out <&4; do
      echo "$out"
      [[ "$out" == usiok* ]] && break
    done

    # init preflight engine silently
    echo "$line" >&7
    read_until_token_discard 8 "usiok" || true
    continue
  fi

  if [[ "$line" == isready* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      echo "readyok"
      continue
    fi

    echo "$line" >&3
    read_until_token_discard 4 "readyok" || true

    echo "$line" >&7
    read_until_token_discard 8 "readyok" || true

    echo "readyok"
    continue
  fi

  # passthrough setup commands
  if [[ "$line" == setoption* ]] || [[ "$line" == usinewgame* ]] || [[ "$line" == position* ]]; then
    [ "$DUMMY_MODE" = "0" ] && echo "$line" >&3 || true
    [ "$DUMMY_MODE" = "0" ] && echo "$line" >&7 || true
    continue
  fi

  if [[ "$line" == go* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      say "‚ùå dlshogi/model.onnx not found"
      echo "bestmove resign"
      continue
    fi

    # preflight
    read PF_CP1 PF_CP2 PF_SPREAD < <(preflight_analyze)
    read BUNKER SPREAD < <(bunker_flag "$PF_CP1" "$PF_CP2")
    HWS="$(get_hws "$PF_CP1" "$PF_SPREAD")"

    [ "$BUNKER" = "1" ] && say "üèñ „Éê„É≥„Ç´„ÉºÂ±ÄÈù¢ÔºàÂ¥ñ=$SPREADÔºâ"
    say "üß† ‰∫∫ÈñìÂãùÁéá: $HWS"

    MODE_LINE="$("$HUMAN_PY" - <<PY 2>/dev/null || echo "‚öñ „Éê„É©„É≥„Çπ"
h=float("$HWS")
print("üõ° Âèó„Åë„Å¶Âãù„Å§" if h>=0.8 else ("‚öñ „Éê„É©„É≥„Çπ" if h>=0.6 else "üî• Êîª„ÇÅ„Å¶Âãù„Å§"))
PY
)"
    say "$MODE_LINE"

    llm_say "{\"phase\":\"MIDGAME\",\"event\":\"GO\",\"cp1\":$PF_CP1,\"cp2\":$PF_CP2,\"spread\":$SPREAD,\"hws\":$HWS}"

    # comeback policy based on last turn (tracked from previous go)
    emit_comeback "$LAST_SCORE" "$LAST_MATE" "$HWS"

    echo "$line" >&3
    pump_until_bestmove
    continue
  fi

  # default passthrough (for other commands)
  [ "$DUMMY_MODE" = "0" ] && echo "$line" >&3 || true
done
SH

chmod +x "$HOME/shogi/wrapper/taso_engine.sh"
