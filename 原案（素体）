cat > "$HOME/shogi/wrapper/taso_engine.sh" <<'SH'
#!/usr/bin/env bash
set -euo pipefail

# =========================================================
# TASO Engine ‚Äî FINAL MEMORY EDITION
# (dlshogi + optional YaneuraOu switch + HumanScore + BUNKER + COMEBACK + SUDDEN DEATH)
# =========================================================

# ========= User toggles =========
TASO_SHOW="${TASO_SHOW:-0}"        # 1„Åß info string Ë°®Á§∫
TASO_MIRACLE="${TASO_MIRACLE:-0}"  # 1„ÅßË©∞„ÅøË¶ã„Åà„Å¶„ÇÇÁ≤ò„Çã
TASO_LOG="${TASO_LOG:-1}"
TASO_DEBUG="${TASO_DEBUG:-0}"      # 1„Åßstderr„Å´„Éá„Éê„ÉÉ„Ç∞

# „Éó„É™„Éï„É©„Ç§„ÉàÔºàHumanScore/„Éê„É≥„Ç´„ÉºÂà§ÂÆöÁî®Ôºâ
PREFLIGHT_MS="${PREFLIGHT_MS:-30}" # 20‚Äì50ms Êé®Â•®

# ========= SAFETY HARDENED PATCH =========
# - read„Çø„Ç§„É†„Ç¢„Ç¶„ÉàËøΩÂä†Ôºà„Éè„É≥„Ç∞ÂõûÈÅøÔºâ
# - kill 0 „ÇíÁµ∂ÂØæ„Å´‰Ωø„Çè„Å™„ÅÑÔºàÂç±Èô∫Ôºâ
# - Dummy modeÔºàdlshogi/modelÊú™ÈÖçÁΩÆ„Åß„ÇÇUSIÂøúÁ≠îÔºâ
# - coproc PID „ÇíÊòéÁ§∫ÁÆ°ÁêÜ„Åó„Å¶ÂÆâÂÖ®ÁµÇ‰∫Ü
ENGINE_READ_TIMEOUT="${ENGINE_READ_TIMEOUT:-2}"    # Áßí
ENGINE_LINE_LIMIT="${ENGINE_LINE_LIMIT:-5000}"     # ÁÑ°Èôê„É´„Éº„ÉóÈò≤Ê≠¢
# ========= SAFETY HARDENED PATCH =========

# ========= Paths =========
ROOT="$HOME/shogi"
DL="$ROOT/engines/dlshogi/build/dlshogi"
DL_MODEL="$ROOT/models/dlshogi_model/model.onnx"

HUMAN_AI="$ROOT/humanscore_ai/infer.py"
HUMAN_PY="$ROOT/.venv/bin/python"

# dlshogi main
DL_THREADS="${DL_THREADS:-10}"
MULTIPV="${MULTIPV:-5}"

# dlshogi preflight (ËªΩÈáè)
PREFLIGHT_THREADS="${PREFLIGHT_THREADS:-2}"
PREFLIGHT_MULTIPV="${PREFLIGHT_MULTIPV:-3}"

# ========= SUDDEN DEATH (real pick) =========
### SUDDEN DEATH ADDITION ###
SUDDEN_DEATH_MODE=0
TASO_SD_MPV_MIN="${TASO_SD_MPV_MIN:-2}"
TASO_SD_MPV_MAX="${TASO_SD_MPV_MAX:-3}"
TASO_SD_SCORE_LIMIT="${TASO_SD_SCORE_LIMIT:--600}"
declare -A PV_MOVES
### SUDDEN DEATH ADDITION ###

# ========= State =========
CURRENT_POS=""
MOVE_COUNT=0
LAST_SCORE=0
LAST_MATE=0

# ========= UI helpers =========
say() { [ "$TASO_SHOW" = "1" ] && echo "info string $*"; }
dbg() { [ "$TASO_DEBUG" = "1" ] && echo "[DEBUG] $*" >&2; }

# ========= Engine PIDs / FDs =========
DL_PID=""
PF_PID=""
YN_PID=""

# FDs (default: devnull)
exec 3>/dev/null 4</dev/null 7>/dev/null 8</dev/null 5>/dev/null 6</dev/null

# ========= Dummy mode =========
DUMMY_MODE=0
if [ ! -x "$DL" ] || [ ! -f "$DL_MODEL" ]; then
  DUMMY_MODE=1
fi

# ========= Safety cleanup =========
cleanup() {
  dbg "cleanup start"
  # best-effort "quit"
  { echo "quit" >&3; } 2>/dev/null || true
  { echo "quit" >&7; } 2>/dev/null || true
  { echo "quit" >&5; } 2>/dev/null || true

  # kill only known PIDs (NO kill 0)
  [ -n "${DL_PID:-}" ] && kill "$DL_PID" 2>/dev/null || true
  [ -n "${PF_PID:-}" ] && kill "$PF_PID" 2>/dev/null || true
  [ -n "${YN_PID:-}" ] && kill "$YN_PID" 2>/dev/null || true
  dbg "cleanup done"
}
trap cleanup EXIT INT TERM

# ========= USI read helpers (timeout) =========
read_until_token() {
  local fd="$1" token="$2" line n=0
  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" line <&"$fd"; do
    n=$((n+1))
    [[ "$line" == "$token"* ]] && return 0
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && return 1
  done
  return 1
}

mate_num() {
  local m="${1:-0}"
  [[ "$m" =~ ^-?[0-9]+$ ]] && echo "$m" || echo "0"
}

# ========= HumanScore =========
get_hws() {
  local cp="${1:-0}"
  local spread="${2:-0}"
  if [ -n "${CURRENT_POS:-}" ] && [ -f "$HUMAN_AI" ] && [ -x "$HUMAN_PY" ]; then
    "$HUMAN_PY" "$HUMAN_AI" "$CURRENT_POS" "$cp" "$spread" 2>/dev/null || echo "0.50"
  else
    echo "0.50"
  fi
}

# ========= „Éê„É≥„Ç´„ÉºÂà§ÂÆö =========
bunker_flag() {
  local cp1="${1:-0}" cp2="${2:-0}"
  local spread=$(( cp1 - cp2 ))
  local bunker=0
  if [ "$spread" -ge 300 ] && [ "$cp1" -ge -800 ] && [ "$cp1" -le 800 ]; then
    bunker=1
  fi
  echo "$bunker $spread"
}

# ========= Yaneura binary pick (usiokËøî„Çã„Åæ„ÅßË©¶„Åô) =========
pick_yane() {
  local cand
  while IFS= read -r cand; do
    [ -x "$cand" ] || continue
    if echo -e "usi\nquit\n" | "$cand" 2>/dev/null | grep -q "^usiok"; then
      echo "$cand"
      return 0
    fi
  done < <(find "$ROOT/engines/YaneuraOu/source" -maxdepth 2 -type f -perm -111 -name "YaneuraOu*" 2>/dev/null || true)
  echo ""
  return 1
}
YANE_BIN="$(pick_yane || true)"

# ========= Start engines =========
if [ "$DUMMY_MODE" = "0" ]; then
  dbg "starting dlshogi engines"

  coproc DL_ENG { "$DL" --device metal --model "$DL_MODEL" --threads "$DL_THREADS" --multipv "$MULTIPV"; }
  DL_PID="$COPROC_PID"
  exec 3>&"${DL_ENG[1]}" 4<"${DL_ENG[0]}"

  coproc PF_ENG { "$DL" --device metal --model "$DL_MODEL" --threads "$PREFLIGHT_THREADS" --multipv "$PREFLIGHT_MULTIPV"; }
  PF_PID="$COPROC_PID"
  exec 7>&"${PF_ENG[1]}" 8<"${PF_ENG[0]}"

  if [ -n "${YANE_BIN:-}" ]; then
    coproc YN_ENG { "$YANE_BIN"; }
    YN_PID="$COPROC_PID"
    exec 5>&"${YN_ENG[1]}" 6<"${YN_ENG[0]}"
  fi
else
  dbg "dummy mode: dlshogi/model missing"
fi

# ========= Preflight analyze using PF engine =========
preflight_analyze() {
  local cp1=0 cp2=0
  local best_d1=-1 best_d2=-1

  echo "position $CURRENT_POS" >&7
  echo "go movetime $PREFLIGHT_MS" >&7

  local out d mpv cp n=0
  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" out <&8; do
    n=$((n+1))
    if [[ "$out" == info* ]] && echo "$out" | grep -q "score cp"; then
      d="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="depth"){print $(i+1); exit}}' 2>/dev/null || echo "-1")"
      mpv="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="multipv"){print $(i+1); exit}}' 2>/dev/null || echo "1")"
      cp="$(echo "$out" | sed 's/.*score cp //' | awk '{print $1}' 2>/dev/null || echo "")"

      if [ "$mpv" = "1" ] && [ -n "$cp" ] && [ "$d" -ge "$best_d1" ]; then
        best_d1="$d"; cp1="$cp"
      fi
      if [ "$mpv" = "2" ] && [ -n "$cp" ] && [ "$d" -ge "$best_d2" ]; then
        best_d2="$d"; cp2="$cp"
      fi
    fi
    [[ "$out" == bestmove* ]] && break
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
  done

  local spread=$(( cp1 - cp2 ))
  echo "$cp1 $cp2 $spread"
}

# ========= pump: track multipv1 (depth max) + capture PV lines for sudden-death pick =========
pump_until_bestmove_track_and_pick() {
  local fd="$1"
  local out n=0
  local best_depth=-1
  local best_cp="$LAST_SCORE"
  local best_mate="$LAST_MATE"

  while IFS= read -r -t "$ENGINE_READ_TIMEOUT" out <&"$fd"; do
    n=$((n+1))

    if [[ "$out" == info* ]]; then
      ### SUDDEN DEATH ADDITION (PV CAPTURE) ###
      if echo "$out" | grep -q " multipv " && echo "$out" | grep -q " pv " ; then
        local mpv pv
        mpv="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="multipv"){print $(i+1); exit}}' 2>/dev/null || echo "")"
        pv="$(echo "$out" | sed 's/.* pv //' | awk '{print $1}' 2>/dev/null || echo "")"
        [ -n "$mpv" ] && [ -n "$pv" ] && PV_MOVES["$mpv"]="$pv"
      fi
      ### SUDDEN DEATH ADDITION ###

      # multipv 1 lines for cp/mate tracking
      if echo "$out" | grep -q " multipv 1 " ; then
        local d
        d="$(echo "$out" | awk '{for(i=1;i<=NF;i++) if($i=="depth"){print $(i+1); exit}}' 2>/dev/null || echo "-1")"
        [ -n "$d" ] || d=-1

        if echo "$out" | grep -q "score cp" ; then
          local cp
          cp="$(echo "$out" | sed 's/.*score cp //' | awk '{print $1}' 2>/dev/null || echo "")"
          if [ -n "$cp" ] && [ "$d" -ge "$best_depth" ]; then
            best_depth="$d"
            best_cp="$cp"
          fi
        fi

        if echo "$out" | grep -q " mate " ; then
          local mt
          mt="$(echo "$out" | sed 's/.*mate //' | awk '{print $1}' 2>/dev/null || echo "")"
          if [ -n "$mt" ] && [ "$d" -ge "$best_depth" ]; then
            best_depth="$d"
            best_mate="$mt"
          fi
        fi
      fi

      echo "$out"
      [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
      continue
    fi

    if [[ "$out" == bestmove* ]]; then
      LAST_SCORE="$best_cp"
      LAST_MATE="$best_mate"

      ### SUDDEN DEATH ADDITION (REAL PICK) ###
      if [ "$SUDDEN_DEATH_MODE" = "1" ]; then
        local min="${TASO_SD_MPV_MIN:-2}"
        local max="${TASO_SD_MPV_MAX:-3}"
        local choices=()
        local i
        for i in $(seq "$min" "$max"); do
          [ -n "${PV_MOVES[$i]:-}" ] && choices+=("${PV_MOVES[$i]}")
        done
        if [ "${#choices[@]}" -gt 0 ]; then
          local pick="${choices[$((RANDOM % ${#choices[@]}))]}"
          say "‚ò†üéØ SUDDEN DEATH: pick multipv[$min..$max] => $pick"
          echo "bestmove $pick"
          PV_MOVES=()
          return 0
        fi
      fi
      PV_MOVES=()
      ### SUDDEN DEATH ADDITION ###

      echo "$out"
      return 0
    fi

    echo "$out"
    [ "$n" -ge "$ENGINE_LINE_LIMIT" ] && break
  done

  # timeout / limit fallback
  say "‚ö† engine timeout/limit ‚Üí emergency resign"
  echo "bestmove resign"
  PV_MOVES=()
  return 0
}

# ========= COMEBACK =========
emit_comeback() {
  local score="$1" mate_raw="$2" hws="$3"
  local limit="-600"

  local mate
  mate="$(mate_num "$mate_raw")"

  if [ "$score" -le "$limit" ]; then
    local type roadmap
    if [ "$mate" -gt 0 ] && [ "$mate" -le 7 ]; then
      type="‚ò†‚ö° COMEBACK ‰∏ÄÊíÉÂøÖÊÆ∫"
      roadmap="Ë©∞„ÇÅ„Çç„ÉªÂøÖËá≥„ÇíÁãô„Åà"
    else
      if "$HUMAN_PY" - <<PY >/dev/null 2>&1
h=float("$hws"); import sys; sys.exit(0 if h>=0.45 else 1)
PY
      then
        type="‚ò†üé≠ COMEBACK ‰∫ãÊïÖË™òÁô∫"
        roadmap="Âèó„Åë‰∏ÄÊäû„ÇíËø´„Çå"
      else
        type="‚ò†üêç COMEBACK „Ç∏„ÉØ„Ç∏„ÉØ"
        roadmap="‰ΩìÂã¢„ÇíÂÖ•„ÇåÊõø„Åà„Çã"
      fi

      ### SUDDEN DEATH ADDITION ###
      if [ "$score" -le "$TASO_SD_SCORE_LIMIT" ] && [ "$mate" -eq 0 ]; then
        SUDDEN_DEATH_MODE=1
        type="‚ò†üéØ SUDDEN DEATH È†ìÊ≠ªË™òÁô∫"
        roadmap="Áõ∏Êâã„ÅåÂ¥©„Çå„ÇãÁ≠ã„Çí‚ÄúÁãô„Å£„Å¶‚ÄùÂá∫„Åô"
      else
        SUDDEN_DEATH_MODE=0
      fi
      ### SUDDEN DEATH ADDITION ###
    fi

    say "$type"
    say "‚ñ∂ $roadmap"

    if [ "$TASO_LOG" = "1" ]; then
      mkdir -p "$ROOT/taso_joseki"
      local poshash
      poshash="$(echo "$CURRENT_POS" | shasum | cut -c1-8)"
      echo "$(date),$MOVE_COUNT,$score,$hws,$type,$poshash" >> "$ROOT/taso_joseki/comeback_log.csv"
    fi
  else
    SUDDEN_DEATH_MODE=0
  fi
}

# ========= ÁµÇÁõ§ÂàáÊõøÔºàÂøÖËá≥ÂÑ™ÂÖàÔºâ =========
should_switch_to_yane() {
  [ -n "${YANE_BIN:-}" ] || return 1

  # sudden death‰∏≠„ÅØÂàáÊõø„Åó„Å™„ÅÑÔºà‚ÄúÂ¥©„Åó‚ÄùÂÑ™ÂÖàÔºâ
  ### SUDDEN DEATH ADDITION ###
  [ "$SUDDEN_DEATH_MODE" = "1" ] && return 1
  ### SUDDEN DEATH ADDITION ###

  local mate
  mate="$(mate_num "$LAST_MATE")"

  if [ "$mate" -gt 0 ] && [ "$mate" -le 5 ] && [ "$TASO_MIRACLE" = "0" ]; then
    return 0
  fi
  if [ "$MOVE_COUNT" -ge 90 ]; then return 0; fi
  if [ "$LAST_SCORE" -ge 2500 ] || [ "$LAST_SCORE" -le -2500 ]; then return 0; fi
  return 1
}

# ========= Main loop =========
while IFS= read -r line; do
  dbg "IN: $line"

  if [[ "$line" == position* ]]; then
    CURRENT_POS="${line#position }"
    MOVE_COUNT="$(
      echo "$line" | awk '{
        for(i=1;i<=NF;i++){
          if($i=="moves"){ print (NF - i); exit }
        }
        print 0
      }' 2>/dev/null
    )"
  fi

  if [[ "$line" == quit* ]]; then
    { echo "$line" >&3; } 2>/dev/null || true
    { echo "$line" >&7; } 2>/dev/null || true
    { echo "$line" >&5; } 2>/dev/null || true
    exit 0
  fi

  if [[ "$line" == usi* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      echo "id name TASO (ERROR: dlshogi/model.onnx missing)"
      echo "id author TASO"
      echo "usiok"
      continue
    fi

    echo "$line" >&3
    echo "$line" >&7
    read_until_token 4 "usiok" || true
    read_until_token 8 "usiok" || true

    if [ -n "${YANE_BIN:-}" ]; then
      echo "$line" >&5
      read_until_token 6 "usiok" || true
    fi

    echo "usiok"
    continue
  fi

  if [[ "$line" == isready* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      echo "readyok"
      continue
    fi

    echo "$line" >&3
    echo "$line" >&7
    read_until_token 4 "readyok" || true
    read_until_token 8 "readyok" || true

    if [ -n "${YANE_BIN:-}" ]; then
      echo "$line" >&5
      read_until_token 6 "readyok" || true
    fi

    echo "readyok"
    continue
  fi

  if [[ "$line" == setoption* ]] || [[ "$line" == usinewgame* ]] || [[ "$line" == position* ]]; then
    [ "$DUMMY_MODE" = "0" ] && echo "$line" >&3 || true
    [ "$DUMMY_MODE" = "0" ] && echo "$line" >&7 || true
    [ -n "${YANE_BIN:-}" ] && echo "$line" >&5 || true
    continue
  fi

  if [[ "$line" == go* ]]; then
    if [ "$DUMMY_MODE" = "1" ]; then
      say "‚ùå dlshogi/model.onnx not found"
      echo "bestmove resign"
      continue
    fi

    # preflight
    read PF_CP1 PF_CP2 PF_SPREAD < <(preflight_analyze)
    read BUNKER SPREAD < <(bunker_flag "$PF_CP1" "$PF_CP2")

    HWS="$(get_hws "$PF_CP1" "$PF_SPREAD")"

    if [ "$TASO_SHOW" = "1" ]; then
      [ "$BUNKER" = "1" ] && say "üèñ „Éê„É≥„Ç´„ÉºÂ±ÄÈù¢ÔºàÂ¥ñ=$SPREADÔºâ"
      say "üß† ‰∫∫ÈñìÂãùÁéá: $HWS"

      # mode line (single source of truth)
      MODE_LINE="$("$HUMAN_PY" - <<PY 2>/dev/null || echo "‚öñ „Éê„É©„É≥„Çπ"
h=float("$HWS")
print("üõ° Âèó„Åë„Å¶Âãù„Å§" if h>=0.8 else ("‚öñ „Éê„É©„É≥„Çπ" if h>=0.6 else "üî• Êîª„ÇÅ„Å¶Âãù„Å§"))
PY
)"
      say "$MODE_LINE"
    fi

    emit_comeback "$LAST_SCORE" "$LAST_MATE" "$HWS"

    ENGINE="DL"
    if should_switch_to_yane; then
      ENGINE="YANE"
      say "üîÑ ÁµÇÁõ§ÔºöÂøÖËá≥ÂÑ™ÂÖà„ÉªÂãù„Å°Âàá„Çä"
    fi

    if [ "$ENGINE" = "DL" ]; then
      echo "$line" >&3
      pump_until_bestmove_track_and_pick 4
    else
      echo "$line" >&5
      pump_until_bestmove_track_and_pick 6
    fi
    continue
  fi

  # default passthrough
  [ "$DUMMY_MODE" = "0" ] && echo "$line" >&3 || true
  [ "$DUMMY_MODE" = "0" ] && echo "$line" >&7 || true
  [ -n "${YANE_BIN:-}" ] && echo "$line" >&5 || true
done
SH

chmod +x "$HOME/shogi/wrapper/taso_engine.sh"
