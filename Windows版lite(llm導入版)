$Root = "$HOME\taso-lite"
New-Item -ItemType Directory -Force -Path $Root | Out-Null
Set-Location $Root

@'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TASO-Lite Proxy for ShogiGUI (Windows, YaneuraOu)
- USI proxy: ShogiGUI <-> YaneuraOu
- Injects short "info string" only on golden triggers
- Optional local LLM (llama.cpp) via taso_llm.py (<= 3 lines)

Env (optional):
  TASO_YANE_EXE=C:\path\to\YaneuraOu.exe   (default: ./YaneuraOu.exe)
  TASO_SHOW=1|0                           (default: 1)
  TASO_LLM=1|0                            (default: 1)
  TASO_LLM_HELPER=.\taso_llm.py           (default: ./taso_llm.py)
  TASO_LLM_TIMEOUT_SEC=0.8                (default: 0.8)
  TASO_LLM_MODEL=C:\path\to\model.gguf    (required if TASO_LLM=1)
  TASO_LLM_CLI=C:\path\to\llama-cli.exe   (optional; default: llama-cli in PATH)
  TASO_OPENING_PLIES=20                   (default: 20)
  TASO_OPENING_SPREAD=250                 (default: 250)
  TASO_BUNKER_SPREAD=300                  (default: 300)
  TASO_COMEBACK_CP=-600                   (default: -600)
"""

import json
import os
import re
import subprocess
import sys
import threading
import time
from dataclasses import dataclass
from typing import Optional, Dict, Tuple

# ---------------------------
# Settings
# ---------------------------
YANE_EXE = os.environ.get("TASO_YANE_EXE", os.path.join(os.getcwd(), "YaneuraOu.exe"))
SHOW = os.environ.get("TASO_SHOW", "1") == "1"

LLM_ENABLED = os.environ.get("TASO_LLM", "1") == "1"
LLM_HELPER = os.environ.get("TASO_LLM_HELPER", os.path.join(os.getcwd(), "taso_llm.py"))
LLM_TIMEOUT = float(os.environ.get("TASO_LLM_TIMEOUT_SEC", "0.8"))
LLM_MODEL = os.environ.get("TASO_LLM_MODEL", "")

OPENING_PLIES = int(os.environ.get("TASO_OPENING_PLIES", "20"))
OPENING_SPREAD = int(os.environ.get("TASO_OPENING_SPREAD", "250"))
BUNKER_SPREAD = int(os.environ.get("TASO_BUNKER_SPREAD", "300"))
COMEBACK_CP = int(os.environ.get("TASO_COMEBACK_CP", "-600"))

# ---------------------------
# Utilities
# ---------------------------
def usi_print(s: str) -> None:
    sys.stdout.write(s + "\n")
    sys.stdout.flush()

def say(s: str) -> None:
    if SHOW:
        usi_print(f"info string {s}")

def llm_say_3lines(payload: Dict) -> None:
    if not (SHOW and LLM_ENABLED):
        return
    if not (os.path.isfile(LLM_HELPER) and os.access(LLM_HELPER, os.X_OK) or os.path.isfile(LLM_HELPER)):
        return
    if not LLM_MODEL or not os.path.isfile(LLM_MODEL):
        return

    try:
        cp = subprocess.run(
            [sys.executable, LLM_HELPER],
            input=json.dumps(payload, ensure_ascii=False),
            text=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            timeout=LLM_TIMEOUT,
            env={**os.environ, "TASO_LLM_MODEL": LLM_MODEL},
        )
        out = (cp.stdout or "").strip()
        if not out:
            return
        for line in out.splitlines()[:3]:
            line = line.strip()
            if line:
                usi_print(f"info string ðŸ—£ {line}")
    except Exception:
        return

def safe_int(x: str, default: int = 0) -> int:
    try:
        return int(x)
    except Exception:
        return default

# Parse helpers for USI info lines
RE_DEPTH = re.compile(r"\bdepth\s+(\d+)\b")
RE_MPV   = re.compile(r"\bmultipv\s+(\d+)\b")
RE_CP    = re.compile(r"\bscore\s+cp\s+(-?\d+)\b")
RE_MATE  = re.compile(r"\bscore\s+mate\s+(-?\d+)\b")

@dataclass
class InfoState:
    # best known at max depth per multipv
    d1: int = -1
    cp1: Optional[int] = None
    d2: int = -1
    cp2: Optional[int] = None
    mate_depth: int = -1
    mate: Optional[int] = None

    def spread(self) -> Optional[int]:
        if self.cp1 is None or self.cp2 is None:
            return None
        return self.cp1 - self.cp2

class TriggerState:
    def __init__(self) -> None:
        self.opening_mode = True
        self.opening_fired = False
        self.bunker_fired = False
        self.comeback_fired = False
        self.mate_fired = False

    def reset_for_go(self, move_count: int) -> None:
        self.opening_mode = move_count <= OPENING_PLIES
        self.opening_fired = False
        self.bunker_fired = False
        self.comeback_fired = False
        self.mate_fired = False

# ---------------------------
# Engine process + threads
# ---------------------------
class EngineProxy:
    def __init__(self, exe: str) -> None:
        self.exe = exe
        self.proc = subprocess.Popen(
            [exe],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            bufsize=1,
        )
        assert self.proc.stdin and self.proc.stdout
        self._in = self.proc.stdin
        self._out = self.proc.stdout

        self.lock = threading.Lock()
        self.info = InfoState()
        self.trig = TriggerState()
        self.move_count = 0

        self._reader = threading.Thread(target=self._read_loop, daemon=True)
        self._reader.start()

        # For â€œblock until tokenâ€ waits
        self._token_cv = threading.Condition()
        self._last_line: str = ""

    def send(self, line: str) -> None:
        with self.lock:
            self._in.write(line + "\n")
            self._in.flush()

    def close(self) -> None:
        try:
            self.send("quit")
        except Exception:
            pass
        try:
            self.proc.terminate()
        except Exception:
            pass

    def wait_for(self, prefix: str, timeout: float = 3.0) -> bool:
        end = time.time() + timeout
        with self._token_cv:
            while time.time() < end:
                if self._last_line.startswith(prefix):
                    return True
                remain = end - time.time()
                self._token_cv.wait(timeout=max(0.05, min(0.2, remain)))
        return False

    def _handle_position(self, line: str) -> None:
        # Count moves after "moves"
        # position ... moves m1 m2 ...
        parts = line.strip().split()
        if "moves" in parts:
            idx = parts.index("moves")
            self.move_count = max(0, len(parts) - idx - 1)
        else:
            self.move_count = 0

    def _reset_info_for_go(self) -> None:
        self.info = InfoState()
        self.trig.reset_for_go(self.move_count)

    def _parse_info_line(self, line: str) -> None:
        d = -1
        m = RE_DEPTH.search(line)
        if m:
            d = safe_int(m.group(1), -1)
        mpv = 1
        m = RE_MPV.search(line)
        if m:
            mpv = safe_int(m.group(1), 1)

        mcp = RE_CP.search(line)
        if mcp:
            cp = safe_int(mcp.group(1), 0)
            if mpv == 1 and d >= self.info.d1:
                self.info.d1 = d
                self.info.cp1 = cp
            elif mpv == 2 and d >= self.info.d2:
                self.info.d2 = d
                self.info.cp2 = cp

        mm = RE_MATE.search(line)
        if mm:
            mate = safe_int(mm.group(1), 0)
            if d >= self.info.mate_depth:
                self.info.mate_depth = d
                self.info.mate = mate

    def _maybe_fire_triggers(self) -> None:
        # Called after info parse updates
        spread = self.info.spread()

        # Opening break: early + spread big (once)
        if self.trig.opening_mode and (not self.trig.opening_fired) and spread is not None and spread >= OPENING_SPREAD:
            self.trig.opening_fired = True
            llm_say_3lines({
                "event": "OPENING_BREAK",
                "phase": "OPENING->MID",
                "reason": "spread",
                "move_count": self.move_count,
                "spread": spread,
                "cp1": self.info.cp1,
                "cp2": self.info.cp2,
            })

        # BUNKER: spread big (once per go)
        if (not self.trig.bunker_fired) and spread is not None and spread >= BUNKER_SPREAD:
            self.trig.bunker_fired = True
            llm_say_3lines({
                "event": "BUNKER",
                "phase": "BUNKER",
                "move_count": self.move_count,
                "spread": spread,
                "cp1": self.info.cp1,
                "cp2": self.info.cp2,
            })

        # COMEBACK: pv1 cp very negative (once per go)
        if (not self.trig.comeback_fired) and self.info.cp1 is not None and self.info.cp1 <= COMEBACK_CP:
            self.trig.comeback_fired = True
            llm_say_3lines({
                "event": "COMEBACK",
                "phase": "COMEBACK",
                "move_count": self.move_count,
                "cp1": self.info.cp1,
                "spread": spread,
            })

        # SUDDEN DEATH: mate appears (once per go)
        if (not self.trig.mate_fired) and self.info.mate is not None:
            self.trig.mate_fired = True
            llm_say_3lines({
                "event": "SUDDEN_DEATH" if (self.info.mate or 0) != 0 else "MATE_HINT",
                "phase": "ENDGAME",
                "move_count": self.move_count,
                "mate": self.info.mate,
                "cp1": self.info.cp1,
                "spread": spread,
            })

    def _read_loop(self) -> None:
        while True:
            line = self._out.readline()
            if not line:
                break
            line = line.rstrip("\n")

            # expose for wait_for()
            with self._token_cv:
                self._last_line = line
                self._token_cv.notify_all()

            # Parse info for triggers (we do NOT change engine output)
            if line.startswith("info "):
                try:
                    self._parse_info_line(line)
                    self._maybe_fire_triggers()
                except Exception:
                    pass

            # Forward engine line to GUI
            usi_print(line)

# ---------------------------
# Main USI loop (GUI -> Proxy -> Engine)
# ---------------------------
def main() -> int:
    if not os.path.isfile(YANE_EXE):
        usi_print("id name TASO-Lite (ERROR: YaneuraOu.exe not found)")
        usi_print("id author TASO")
        usi_print("usiok")
        # keep responding to not freeze GUI
        for line in sys.stdin:
            line = line.strip()
            if line == "isready":
                usi_print("readyok")
            elif line == "quit":
                return 0
        return 0

    eng = EngineProxy(YANE_EXE)

    try:
        for raw in sys.stdin:
            line = raw.strip()
            if not line:
                continue

            # Track position move count (for opening trigger)
            if line.startswith("position "):
                eng._handle_position(line)

            if line == "usi":
                eng.send(line)
                # Just wait a bit; reader thread forwards everything including usiok
                eng.wait_for("usiok", timeout=3.0)
                continue

            if line == "isready":
                # Force MultiPV=2 for spread-based triggers
                eng.send("setoption name MultiPV value 2")
                eng.send(line)
                eng.wait_for("readyok", timeout=3.0)
                continue

            if line.startswith("go"):
                eng._reset_info_for_go()
                eng.send(line)
                continue

            if line == "quit":
                eng.send(line)
                return 0

            # passthrough
            eng.send(line)

    finally:
        eng.close()

    return 0

if __name__ == "__main__":
    raise SystemExit(main())
'@ | Set-Content -Encoding UTF8 -Path ".\taso_lite_proxy.py"

@'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TASO LLM helper (local, safe, 3-line output)
- Reads a JSON dict from stdin
- Calls llama.cpp llama-cli with a strict prompt
- Returns <= 3 lines for USI info string

Env:
  TASO_LLM_CLI=/path/to/llama-cli            (default: llama-cli in PATH)
  TASO_LLM_MODEL=/path/to/model.gguf         (required)
  TASO_LLM_TIMEOUT_SEC=0.8                  (default: 0.8)
  TASO_LLM_MAX_TOKENS=96                    (default: 96)
  TASO_LLM_TEMPERATURE=0.2                  (default: 0.2)
"""

import json
import os
import re
import subprocess
import sys
from typing import Any, Dict, List

PROMPT_BASE = """ã‚ãªãŸã¯å°†æ£‹AIã€ŒTASOã€ã®è§£èª¬è£œåŠ©ã§ã™ã€‚å½¹å‰²ã¯ã€ŒçŠ¶æ³ã®èª¬æ˜Žã€ã¨ã€Œæ³¨æ„ç‚¹ã®æç¤ºã€ã§ã™ã€‚

åˆ¶ç´„ï¼š
- æ–°ã—ã„æˆ¦ç•¥ã‚’ææ¡ˆã—ãªã„
- æœ€å–„æ‰‹ã‚’æŒ‡ç¤ºã—ãªã„
- å‡ºåŠ›ã¯å¿…ãš3è¡Œä»¥å†…
- æŠ½è±¡çš„ãªç²¾ç¥žè«–ã¯ç¦æ­¢
- å±é™ºãƒ»å„ªå…ˆãƒ»ç¦æ­¢ ã®é †ã§ç°¡æ½”ã«æ›¸ã
- 1è¡Œã¯å…¨è§’40æ–‡å­—ç¨‹åº¦ã¾ã§ï¼ˆçŸ­ãï¼‰

å…¥åŠ›ï¼ˆJSONï¼‰ã‚’èª­ã‚“ã§ã€ä¸Šã®åˆ¶ç´„ã§å›žç­”ã—ã¦ãã ã•ã„ã€‚
"""

def _clean_lines(text: str) -> List[str]:
    t = text.strip()
    t = re.sub(r"```.*?```", "", t, flags=re.S)
    t = t.replace("\r\n", "\n").replace("\r", "\n")
    lines = []
    for line in t.split("\n"):
        s = line.strip()
        if not s:
            continue
        s = re.sub(r"^[-*â€¢]+\s*", "", s)
        lines.append(s)
        if len(lines) >= 3:
            break
    if not lines:
        lines = ["çŠ¶æ³ï¼šæƒ…å ±ä¸è¶³ï¼ˆçŸ­ç¸®ï¼‰", "å„ªå…ˆï¼šè½ã¡ç€ã„ã¦å½¢ã‚’å´©ã•ãªã„", "ç¦æ­¢ï¼šç„¡ç†ãªçªã£è¾¼ã¿"]
    return lines[:3]

def main() -> int:
    raw = sys.stdin.read().strip()
    if not raw:
        return 0

    try:
        payload: Dict[str, Any] = json.loads(raw)
    except Exception:
        return 0

    cli = os.environ.get("TASO_LLM_CLI", "llama-cli")
    model = os.environ.get("TASO_LLM_MODEL", "")
    if not model:
        return 0

    timeout_sec = float(os.environ.get("TASO_LLM_TIMEOUT_SEC", "0.8"))
    max_tokens = int(os.environ.get("TASO_LLM_MAX_TOKENS", "96"))
    temperature = float(os.environ.get("TASO_LLM_TEMPERATURE", "0.2"))

    user_block = json.dumps(payload, ensure_ascii=False)
    prompt = PROMPT_BASE + "\nå…¥åŠ›:\n" + user_block + "\n\nå›žç­”:\n"

    args = [
        cli,
        "-m", model,
        "-n", str(max_tokens),
        "--temp", str(temperature),
        "--prompt", prompt,
    ]

    try:
        cp = subprocess.run(
            args,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            timeout=timeout_sec,
        )
        out = cp.stdout or ""
    except subprocess.TimeoutExpired:
        return 0
    except Exception:
        return 0

    lines = _clean_lines(out)
    sys.stdout.write("\n".join(lines))
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
'@ | Set-Content -Encoding UTF8 -Path ".\taso_llm.py"

Write-Host "âœ… Created:" (Resolve-Path ".\taso_lite_proxy.py")
Write-Host "âœ… Created:" (Resolve-Path ".\taso_llm.py")
Write-Host ""
Write-Host "Next:"
Write-Host "1) Put YaneuraOu.exe in $Root  (or set TASO_YANE_EXE)"
Write-Host "2) (Optional) Put llama-cli.exe and model.gguf somewhere, set TASO_LLM_MODEL"
Write-Host "3) Register engine in ShogiGUI: python taso_lite_proxy.py"
